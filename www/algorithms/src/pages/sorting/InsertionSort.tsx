import React from 'react'
import { Scatter } from 'react-chartjs-2'

import Markdown from '../../components/Markdown'

const data = {
  datasets: [
    {
      label: 'BM_InsertionSortAsc',
      data: [
        { x: 8, y: 0.2918495671196479 },
        { x: 16, y: 0.36943662639841374 },
        { x: 32, y: 0.6580587032955038 },
        { x: 64, y: 1.7616306161259128 },
        { x: 128, y: 6.230063451980293 },
        { x: 256, y: 23.830196628259017 },
        { x: 512, y: 93.13489904735984 },
        { x: 1024, y: 369.4964722954961 },
        { x: 2048, y: 1469.9490636942176 },
        { x: 4096, y: 5881.095756302613 },
        { x: 8192, y: 23437.844166666844 },
        { x: 16384, y: 93811.6321428572 },
        { x: 32768, y: 374630.4245000003 },
      ],
      backgroundColor: 'rgba(255, 99, 132)',
      borderColor: 'rgba(255, 99, 132, 0.2)',
      showLine: true,
    },
    {
      label: 'BM_InsertionSortDesc',
      data: [
        { x: 8, y: 0.2917386479762297 },
        { x: 16, y: 0.3318095858674451 },
        { x: 32, y: 0.5601437984281256 },
        { x: 64, y: 1.5304529868129546 },
        { x: 128, y: 6.066844192631836 },
        { x: 256, y: 27.079582266751256 },
        { x: 512, y: 112.98947449967193 },
        { x: 1024, y: 463.150292023777 },
        { x: 2048, y: 1872.3465106951778 },
        { x: 4096, y: 7539.2845268819165 },
        { x: 8192, y: 30331.34991304341 },
        { x: 16384, y: 120862.97466666688 },
        { x: 32768, y: 482396.80299999856 },
      ],
      backgroundColor: 'rgba(54, 162, 235)',
      borderColor: 'rgba(54, 162, 235, 0.2)',
      showLine: true,
    },
    {
      label: 'BM_InsertionSortRandom',
      data: [
        { x: 8, y: 0.33421957064127317 },
        { x: 16, y: 0.47322485615295307 },
        { x: 32, y: 0.8940612472837445 },
        { x: 64, y: 2.324714829870189 },
        { x: 128, y: 7.6703040190085785 },
        { x: 256, y: 28.33437775358282 },
        { x: 512, y: 108.93120700334555 },
        { x: 1024, y: 428.0854511598675 },
        { x: 2048, y: 1693.5027004830636 },
        { x: 4096, y: 6684.602314285691 },
        { x: 8192, y: 26591.051884615797 },
        { x: 16384, y: 106024.79885714088 },
        { x: 32768, y: 422576.6025000013 },
      ],
      backgroundColor: 'rgba(255, 206, 86)',
      borderColor: 'rgba(255, 206, 86, 0.2)',
      showLine: true,
    },
  ],
  options: {
    responsive: true,
  },
}

const data2 = {
  datasets: [
    {
      label: 'BM_InsertionSort2Asc',
      data: [
        { x: 8, y: 0.28042589190926653 },
        { x: 16, y: 0.28380394090446287 },
        { x: 32, y: 0.29279756377334903 },
        { x: 64, y: 0.3160176975424335 },
        { x: 128, y: 0.3529229618059298 },
        { x: 256, y: 0.4256432742764239 },
        { x: 512, y: 0.5734635311185659 },
        { x: 1024, y: 0.8676735048118396 },
        { x: 2048, y: 1.4533844246745966 },
        { x: 4096, y: 2.6249241406571637 },
        { x: 8192, y: 4.998288821091965 },
        { x: 16384, y: 9.737206291469864 },
        { x: 32768, y: 19.18769926583129 },
      ],
      backgroundColor: 'rgba(255, 99, 132)',
      borderColor: 'rgba(255, 99, 132, 0.2)',
      showLine: true,
    },
    {
      label: 'BM_InsertionSort2Desc',
      data: [
        { x: 8, y: 0.2873351983961651 },
        { x: 16, y: 0.316572858653513 },
        { x: 32, y: 0.48145228601674794 },
        { x: 64, y: 1.047081462568044 },
        { x: 128, y: 3.0759503242668615 },
        { x: 256, y: 10.614449596696689 },
        { x: 512, y: 39.83659024611424 },
        { x: 1024, y: 155.2412980599364 },
        { x: 2048, y: 611.0902489042445 },
        { x: 4096, y: 2424.034319444651 },
        { x: 8192, y: 9642.192777778211 },
        { x: 16384, y: 38614.02444444392 },
        { x: 32768, y: 154213.61479999547 },
      ],
      backgroundColor: 'rgba(54, 162, 235)',
      borderColor: 'rgba(54, 162, 235, 0.2)',
      showLine: true,
    },
    {
      label: 'BM_InsertionSort2Random',
      data: [
        { x: 8, y: 0.3152800651677539 },
        { x: 16, y: 0.379986670244821 },
        { x: 32, y: 0.5387438347305712 },
        { x: 64, y: 0.9647208104849145 },
        { x: 128, y: 2.3069439057725094 },
        { x: 256, y: 6.75026126074009 },
        { x: 512, y: 23.24816082906691 },
        { x: 1024, y: 90.50192214809644 },
        { x: 2048, y: 359.2424664949891 },
        { x: 4096, y: 1342.249353369645 },
        { x: 8192, y: 5020.147176470042 },
        { x: 16384, y: 19535.92337142993 },
        { x: 32768, y: 77591.53155555666 },
      ],
      backgroundColor: 'rgba(255, 206, 86)',
      borderColor: 'rgba(255, 206, 86, 0.2)',
      showLine: true,
    },
  ],
  options: {
    responsive: true,
  },
}

const data3 = {
  datasets: [
    {
      label: 'BM_InsertionSort3Asc',
      data: [
        { x: 8, y: 0.28149903000597937 },
        { x: 16, y: 0.2934181420224502 },
        { x: 32, y: 0.3112906812750447 },
        { x: 64, y: 0.3473996401886236 },
        { x: 128, y: 0.4150486948661405 },
        { x: 256, y: 0.5391632689362338 },
        { x: 512, y: 0.782051857954382 },
        { x: 1024, y: 1.27248161680784 },
        { x: 2048, y: 2.2498873950130847 },
        { x: 4096, y: 4.206444390804036 },
        { x: 8192, y: 8.169503984963812 },
        { x: 16384, y: 15.996464111454978 },
        { x: 32768, y: 31.713688417610086 },
      ],
      backgroundColor: 'rgba(255, 99, 132)',
      borderColor: 'rgba(255, 99, 132, 0.2)',
      showLine: true,
    },
    {
      label: 'BM_InsertionSort3Desc',
      data: [
        { x: 8, y: 0.2863185881864001 },
        { x: 16, y: 0.3108383353607815 },
        { x: 32, y: 0.41156072693386253 },
        { x: 64, y: 0.9786651386042904 },
        { x: 128, y: 2.653523947150981 },
        { x: 256, y: 8.091521226766965 },
        { x: 512, y: 28.287791648171993 },
        { x: 1024, y: 106.56534312235034 },
        { x: 2048, y: 412.16255889279535 },
        { x: 4096, y: 1631.5400279071891 },
        { x: 8192, y: 6742.666634614886 },
        { x: 16384, y: 27347.07503846296 },
        { x: 32768, y: 109294.5561666679 },
      ],
      backgroundColor: 'rgba(54, 162, 235)',
      borderColor: 'rgba(54, 162, 235, 0.2)',
      showLine: true,
    },
    {
      label: 'BM_InsertionSort3Random',
      data: [
        { x: 8, y: 0.32247992567773226 },
        { x: 16, y: 0.39400969089839605 },
        { x: 32, y: 0.5421013779713074 },
        { x: 64, y: 0.9220210023423834 },
        { x: 128, y: 1.9683923018389349 },
        { x: 256, y: 5.188859919893537 },
        { x: 512, y: 16.201601491412198 },
        { x: 1024, y: 56.8639647892602 },
        { x: 2048, y: 213.58032186356274 },
        { x: 4096, y: 825.4216517647623 },
        { x: 8192, y: 3311.6155523812618 },
        { x: 16384, y: 13475.357000000526 },
        { x: 32768, y: 54346.851692306824 },
      ],
      backgroundColor: 'rgba(255, 206, 86)',
      borderColor: 'rgba(255, 206, 86, 0.2)',
      showLine: true,
    },
  ],
  options: {
    responsive: true,
  },
}

function InsertionSort() {
  return (
    <>
      <h2>Insertion Sort</h2>
      <div>
        <Markdown>{`
トランプや麻雀などで、手元のカードを分かりやすいよう整列させてもっていて、
そこに新しいカードを追加するときに、入れる場所を探して挿入するといったことをする人は多いと思う。
（それをすると手札の情報を相手に与えてしまうので、本当はやめたほうがいいですが）
このときの操作をカードが1枚から繰り返していくと挿入ソート(insert sort)になる。

配列の場合、挿入するためには要素を一つずつ右にずらす必要がある。
そこで、ソート済みの配列を右から見ていき、新たに挿入したい要素が比較対象よりも小さい間、
要素を入れ替え続ければよい。

~~~c++
void insertion_sort(int *arr, int n) {
  for (int i = 1; i < n; ++i) {
      for (int j = i; j > 0; --j) {
          if (arr[j] < arr[j - 1]) {
              int tmp = arr[j - 1];
              arr[j - 1] = arr[j];
              arr[j] = tmp;
          }
      }
  }
}
~~~
        `}</Markdown>
        <Scatter data={data} />
        <Markdown>{`
上記のプログラムにおいて、
arr[i - 1]までの配列がソート済みであることから、
一度、挿入しようとする要素a[j]と同じかより小さな要素を見つけた後は、
それ以降、jのループを回す必要がないことに注意すると、
プログラムは次のように改良することができる。

~~~c++
void insertion_sort2(int *arr, int n) {
  for (int i = 1; i < n; ++i) {
      int tmp = arr[i];
      // search the position where the value is smaller than or equals to tmp.
      int j;
      for (j = i; j > 0; --j) {
          if (arr[j - 1] <= tmp) {
              break;
          }
          arr[j] = arr[j - 1];
      }
      arr[j] = tmp;
  }
}
~~~
        `}</Markdown>
        <Scatter data={data2} />

        <Markdown>{`
BM_InsertionSort2Ascにあるように、もともと整列済みの配列に対しては即座にループが終了することから大幅な高速化が達成できている。
元々、整列していた配列のうち、ほんの一部の値が変化したものであったり、数個新しい要素を追加するといった状況ではinsertion sortは、非常に高速に動作する。

逆に、全くの逆順の配列をソートするとき、insertion sortは元のプログラムと比較回数は一緒のはずが、
交換操作での値の移動が半分となっているために、この場合でも元のプログラムよりも速くなる。

### 番兵 (Sentinel)

上記のプログラムにおいて、内側のループでは2つの比較 j > 0 と arr[j - 1] <= tmp が行われている。
しかし、配列の一番左に配列内で最も小さな要素が置かれているなら、この j > 0 の比較は不要となる。

~~~c++
void insertion_sort3(int *arr, int n) {
  if (n == 0) return;

  int min_pos = n - 1;
  for (int i = n - 1; i > 0; --i) {
      if (arr[i - 1] < arr[min_pos]) {
          min_pos = i - 1;
      }
  }
  int tmp = arr[min_pos];
  arr[min_pos] = arr[0];
  arr[0] = tmp;

  for (int i = 2; i < n; ++i) {
      int tmp = arr[i];
      // search the position where the value is smaller than or equals to tmp.
      int j = i;
      while (tmp < arr[j - 1]) {
          arr[j] = arr[j - 1];
          --j;
      }
      arr[j] = tmp;
  }
}
~~~
        `}</Markdown>
        <Scatter data={data3} />

        <Markdown>{`
元のプログラムでほとんどのケースで j > 0 が成り立つので、分岐予測が働いていると考えられるが、それでもなお、これだけ高速化される。
        `}</Markdown>
      </div>
    </>
  )
}

export default InsertionSort
